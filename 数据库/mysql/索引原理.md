MySQL索引使用的数据结构主要有**BTree索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为**单条记录查询**的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

### 一张表可以建16个索引

mysql 可支持16个索引，最大索引长度256字节。

https://tech.meituan.com/2014/06/30/mysql-index.html

### B树

B+树索引原理模型：https://www.jianshu.com/p/e966112dbf8c

MySQL的BTree索引使用的是B树中的**B+Tree**，但对于主要的两种存储引擎的实现方式是不同的。

**MyISAM:** 

MyISAM 用的是**非聚集索引**方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的**物理地址**

在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 **data 域的值**，然后以 data 域的值为地址**读取相应的数据记录**。



**InnoDB**:

InnoDB 是**聚集索引**方式，因此数据和索引都存储在同一个文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+树。 B+树的叶子节点存储的是主键 ID 对应的数据，比如在执行 select * from user_info where id=15 这个语句时，InnoDB 就会查询这颗主键 ID 索引 B+树，找到对应的 user_name='Bob'

- 其**数据文件本身就是索引文件**。其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点**data域保存了完整的数据记录**。这个索引的**key是数据表的主键**，因此InnoDB表数据文件本身就是主索引。这被称为“**聚簇索引**（或聚集索引）”。
- 而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。** PS：整理自《Java工程师修炼之道》

#### 对于主键索引，MyIsam和InNODB的区别



#### 为什么用B+树

[为什么用B+树](https://mp.weixin.qq.com/s/-1FJq7jhxzZT2CGjggsuXg)

https://cloud.tencent.com/developer/article/1543335

哈希：速度快，但存在hash冲突，和不能范围查找。

二叉树：如果范围查询，会产生回旋查找。

B树：

B+树：叶子节点是双向链表。存数据的



1. B+树非叶子节点上是不存储数据的，==仅存储键值==，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是==16KB==。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 

2. 因为B+树索引的所有数据均存储在==叶子节点==，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。  

有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。

其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是**说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。**



#### 最左前缀原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作==联合索引==。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：

```
select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引            
```

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。

#### 注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

MySQL 5.7 版本后，可以通过查询 sys 库的 `schema_redundant_indexes` 表来查看冗余索引

#### 为表字段添加索引

1.添加PRIMARY KEY（主键索引）

```mysql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```

2.添加UNIQUE(唯一索引)

```mysql
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```

3.添加INDEX(普通索引)

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

4.添加FULLTEXT(全文索引)

```mysql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```

5.添加多列索引

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

#### 索引如何提升查找速度

mysql数据存储结构是页，

- **各个数据页可以组成一个双向链表**
- 每个数据页中的记录又可以组成一个**单向链表**
  - 每个数据页都会为存储在它里边儿的记录生成一个**页目录**，在通过主键查找某条记录的时候可以在页目录中使用**二分法快速定位到对应的槽**，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
  - 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。



所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**
2. **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**

**使用索引查询**

没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 **“目录”** 就可以很快地定位到对应的页上了

![](/Users/hayder/Documents/github/JavaStudy/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/images/%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2.jfif)



#### 什么时候建索引

主键自动建索引

频繁查询字段要建索引

关联查询的字段，外键关系要建索引

统计或分组的字段，要建索引

组合索引比单键索引性价比更高

#### 索引没有命中

1、如果条件中有==**or**== ，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因）

**注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引**

如果出现OR的一个条件没有索引时，建议使用 **==union== ，拼接多个查询语句**



2、**like**查询是以**%**开头，索引不会命中



3、如果列类型是**字符串**，那一定要在条件中将数据使用**引号引用起来**,否则不使用索引

###hash

哈希算法：也叫散列算法，就是把任意值(key)通过哈希函数变换为固定长度的 key 地址，通过这个地址进行具体数据的数据结构。