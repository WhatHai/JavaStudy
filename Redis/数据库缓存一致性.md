数据库缓存最终一致性方案

## 一、基于过期时间

通过 key 的过期时间，mysql 更新时，redis 不更新。这种方式实现简单，但不一致的时间会很长。如果读请求非常频繁，且过期时间比较长，则会产生很多长期的脏数据。

优点：

- 开发成本低，易于实现；
- 管理成本低，出问题的概率会比较小。

不足

- 完全依赖过期时间，时间太短容易缓存频繁失效，太长容易有长时间更新延迟（不一致）

## 二、同时更新

更新 mysql 时，同时更新 redis

![redis缓存一致性2](images/redis缓存一致性2.jpg)

优点

- 相对方案一，更新延迟更小。

不足

- 如果更新 mysql 成功，更新 redis 却失败，就退化到了方案一；
- 在高并发场景，业务 server 需要和 mysql,redis 同时进行连接。这样是损耗双倍的连接资源，容易造成连接数过多的问题。

## 三、同步写，消息队列

同步写 redis 进行优化，增加消息队列，将 redis 更新操作交给 kafka，由消息队列保证可靠性，再搭建一个消费服务，来异步更新 redis

![redis缓存一致性3](images/redis缓存一致性3.jpg)

优点

- 消息队列可以用一个句柄，很多消息队列客户端还支持本地缓存发送，有效解决了方案二连接数过多的问题；
- 使用消息队列，实现了逻辑上的解耦；
- 消息队列本身具有可靠性，通过手动提交等手段，可以至少一次消费到 redis。

不足

- 依旧解决不了时序性问题，如果多台业务服务器分别处理针对同一行数据的两条请求，举个栗子，a = 1；a = 5;，如果 mysql 中是第一条先执行，而进入 kafka 的顺序是第二条先执行，那么数据就会产生不一致。
- 引入了消息队列，同时要增加服务消费消息，成本较高。

##四、binlog更新redis

通过订阅 binlog 来更新 redis，把我们搭建的消费服务，作为 mysql 的一个 slave，订阅 binlog，解析出更新内容，再更新到 redis。

![redis缓存一致性](images/redis缓存一致性.jpg)

优点

- 在 mysql 压力不大情况下，延迟较低；
- 和业务完全解耦；
- 解决了时序性问题。

缺点

- 要单独搭建一个同步服务，并且引入 binlog 同步机制，成本较大。



## 五、延时双删保证数据一致性

> 一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

**串行化之**后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

更多内容可以查看：https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md

**1、有缓存和数据库的情况下如何更新：**

先删除缓存，再修改数据库，如果数据库修改失败，那数据库是旧数据，缓存为空。再次读的时候缓存没有，就会直接读数据库的旧值，然后更新到缓存

**2、复杂一点的情况**：

先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，**查到了修改前的旧数据**，放到了缓存中。随后数据变更的程序完成了数据库的修改

**解决方案：**延时双删。

![延时双删](images/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0.jpeg)







延时双删不能严格保证一致性：

​	如果一个线程读取，另一个线程马上要更新，拿到旧数据。

## 六、分布式锁保证严格一致性

采用乐观锁，在写缓存的时候加锁控制，读的时候放开。

推荐一种方案：**分布式锁**（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 

判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

在实践中，当然是从以可靠性为主。所以首推Zookeeper。

参考：

- https://www.jianshu.com/p/8bddd381de06

